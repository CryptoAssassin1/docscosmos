---
title: "EIP-7702: Set EOA Code"
description: "Implementation of EIP-7702 for enabling externally owned accounts to execute smart contract code temporarily"
icon: "user-gear"
---

EIP-7702 enables externally owned accounts (EOAs) to temporarily execute smart contract code through code delegation, unlocking powerful new use cases like account abstraction, batched operations, and enhanced wallet functionality.

## Overview

### What is EIP-7702?

EIP-7702 allows EOA accounts to delegate their code execution to smart contracts for the duration of a transaction. This enables EOAs to:

- **Execute Smart Contract Logic:** Run complex contract code from EOA context
- **Account Abstraction:** Implement custom transaction validation and execution
- **Batched Operations:** Perform multiple operations in a single transaction
- **Enhanced Wallets:** Add programmable features to standard wallet addresses

### Key Concepts

**Code Delegation:** EOAs temporarily "borrow" code from smart contracts
**Authorization List:** Signed permissions allowing code delegation
**Temporary State:** Code delegation only lasts for the transaction duration
**Nonce Management:** Authorizations require specific nonce values for security

## Cosmos EVM Implementation

### Implementation Status

Cosmos EVM provides **full EIP-7702 support** with the following components:

| Component | Implementation | Source |
|-----------|----------------|---------|
| **SetCodeTx Transaction Type** |  Complete | [`tests/integration/x/vm/state_transition_benchmark.go:47`](https://github.com/cosmos/evm/blob/main/tests/integration/x/vm/state_transition_benchmark.go#L47) |
| **Authorization Validation** |  Complete | [`x/vm/keeper/state_transition.go:563`](https://github.com/cosmos/evm/blob/main/x/vm/keeper/state_transition.go#L563) |
| **Code Delegation** |  Complete | [`x/vm/keeper/state_transition.go:536`](https://github.com/cosmos/evm/blob/main/x/vm/keeper/state_transition.go#L536) |
| **Ante Handler Support** |  Complete | [`ante/evm/06_account_verification.go:33`](https://github.com/cosmos/evm/blob/main/ante/evm/06_account_verification.go#L33) |
| **RPC Integration** |  Complete | [`rpc/types/utils.go:322+`](https://github.com/cosmos/evm/blob/main/rpc/types/utils.go#L322) |

### Differences from Ethereum EIP-7702

**Similarities with Ethereum:**
-  Same transaction structure (`SetCodeTx`)
-  Same authorization signature format
-  Same nonce validation rules
-  Same delegation bytecode format
-  Same gas cost parameters

**Cosmos EVM Enhancements:**
- ** Instant Finality:** Delegations are final after one block (~2s) vs. 12+ confirmations
- ** Lower Gas Costs:** Typically much lower transaction costs than Ethereum mainnet
- ** Enhanced Debugging:** Better error messages and transaction tracing
- ** IBC Integration:** Delegated code can interact with IBC precompiles

## Transaction Structure

### SetCodeTx Format

```go
// SetCodeTx transaction structure
type SetCodeTx struct {
    ChainID   *uint256.Int                // Chain ID for EIP-155
    Nonce     uint64                      // Account nonce
    GasTipCap *uint256.Int                // Priority fee per gas
    GasFeeCap *uint256.Int                // Maximum fee per gas  
    Gas       uint64                      // Gas limit
    To        *common.Address             // Recipient address
    Value     *uint256.Int                // ETH value to transfer
    Data      []byte                      // Contract call data
    AccessList ethtypes.AccessList        // EIP-2930 access list
    AuthList   []SetCodeAuthorization     // EIP-7702 authorization list
    
    // Signature values
    V *uint256.Int
    R *uint256.Int  
    S *uint256.Int
}
```

### SetCodeAuthorization Structure

```go
// Authorization allowing code delegation
type SetCodeAuthorization struct {
    ChainID uint256.Int     // Chain ID (0 = any chain)
    Address common.Address  // Target contract address
    Nonce   uint64         // Authority's current nonce
    
    // Authorization signature
    V uint8
    R *uint256.Int
    S *uint256.Int
}
```

**Source:** [`tests/integration/x/vm/state_transition_benchmark.go:47-55`](https://github.com/cosmos/evm/blob/main/tests/integration/x/vm/state_transition_benchmark.go#L47-55)

## Usage Examples

### Basic Code Delegation

```javascript
// Example: Delegate EOA to execute multicall contract
import { ethers } from "ethers";

async function createDelegatedMulticall() {
    const wallet = new ethers.Wallet(privateKey, provider);
    const multicallAddress = "0x..."; // Deployed multicall contract
    
    // Create authorization for code delegation
    const authorization = {
        chainId: 9000,           // Your EVM chain ID
        address: multicallAddress, // Contract to delegate to
        nonce: await wallet.getNonce(), // Current nonce
    };
    
    // Sign authorization
    const authSignature = await signAuthorization(authorization, wallet);
    
    // Create SetCode transaction
    const tx = {
        type: 4, // SetCodeTxType
        chainId: 9000,
        nonce: authorization.nonce + 1,
        gasLimit: 500000,
        gasFeeCap: ethers.parseUnits("20", "gwei"),
        gasTipCap: ethers.parseUnits("1", "gwei"),
        to: wallet.address, // Self-delegation
        value: 0,
        data: "0x", // No direct call data
        accessList: [],
        authorizationList: [{
            chainId: authorization.chainId,
            address: authorization.address,
            nonce: authorization.nonce,
            v: authSignature.v,
            r: authSignature.r,
            s: authSignature.s,
        }]
    };
    
    // Send transaction - EOA will execute as multicall contract
    return await wallet.sendTransaction(tx);
}
```

### Account Abstraction Example

```solidity
// Custom account logic contract
contract CustomAccountLogic {
    mapping(address => uint256) public customNonces;
    
    function validateTransaction(
        address sender,
        bytes calldata signature,
        bytes calldata txData
    ) external view returns (bool) {
        // Custom validation logic
        // Could implement multi-sig, time-locks, spending limits, etc.
        return true;
    }
    
    function executeTransaction(
        address target,
        uint256 value,
        bytes calldata data
    ) external returns (bool success, bytes memory result) {
        // Custom execution logic
        (success, result) = target.call{value: value}(data);
        
        // Update custom state
        customNonces[msg.sender]++;
        
        return (success, result);
    }
}

// Usage: EOA delegates to this contract for advanced functionality
```

### Batched Operations Example

```javascript
// Example: Batch multiple DeFi operations in one transaction
async function batchDeFiOperations() {
    const batchExecutorAddress = "0x..."; // Deployed batch executor contract
    
    // Authorization to use batch executor
    const authorization = await signAuthorization({
        chainId: 9000,
        address: batchExecutorAddress,
        nonce: await wallet.getNonce(),
    }, wallet);
    
    // Encode batch operations
    const operations = [
        // 1. Swap tokens on DEX
        {
            target: dexAddress,
            data: dex.interface.encodeFunctionData("swap", [tokenA, tokenB, amount]),
            value: 0
        },
        // 2. Provide liquidity
        {
            target: poolAddress,  
            data: pool.interface.encodeFunctionData("addLiquidity", [tokenA, tokenB]),
            value: 0
        },
        // 3. Stake LP tokens
        {
            target: farmAddress,
            data: farm.interface.encodeFunctionData("stake", [lpAmount]),
            value: 0
        }
    ];
    
    // Execute all operations atomically via delegation
    const tx = {
        type: 4, // SetCodeTxType
        authorizationList: [authorization],
        to: wallet.address,
        data: batchExecutor.interface.encodeFunctionData("executeBatch", [operations]),
        gasLimit: 1000000,
        // ... other parameters
    };
    
    return await wallet.sendTransaction(tx);
}
```

### Wallet Enhancement Example

```solidity
// Enhanced wallet contract with spending limits and recovery
contract EnhancedWallet {
    mapping(address => uint256) public dailyLimits;
    mapping(address => uint256) public dailySpent;
    mapping(address => uint256) public lastSpendDate;
    mapping(address => address) public recoveryAddresses;
    
    modifier withinDailyLimit(uint256 amount) {
        uint256 today = block.timestamp / 1 days;
        if (lastSpendDate[msg.sender] < today) {
            dailySpent[msg.sender] = 0;
            lastSpendDate[msg.sender] = today;
        }
        
        require(dailySpent[msg.sender] + amount <= dailyLimits[msg.sender], "Daily limit exceeded");
        dailySpent[msg.sender] += amount;
        _;
    }
    
    function transfer(
        address to,
        uint256 amount
    ) external withinDailyLimit(amount) returns (bool) {
        // Safe transfer with built-in limits
        payable(to).transfer(amount);
        return true;
    }
    
    function recoverAccount(
        address newOwner
    ) external {
        require(msg.sender == recoveryAddresses[tx.origin], "Unauthorized recovery");
        // Recovery logic...
    }
}

// Usage: Users delegate to this contract for enhanced security features
```

## Implementation Details

### Authorization Process

**Step 1: Create Authorization**
```javascript
// Create authorization object
const authorization = {
    chainId: 9000,                    // EVM chain ID (0 = any chain)
    address: "0x...",                 // Contract address to delegate to
    nonce: await wallet.getNonce(),   // Current account nonce
};
```

**Step 2: Sign Authorization**
```javascript
// EIP-7702 authorization signature
const domain = {
    name: "SET_CODE",
    version: "1",
    chainId: authorization.chainId,
};

const types = {
    Authorization: [
        { name: "chainId", type: "uint256" },
        { name: "address", type: "address" },
        { name: "nonce", type: "uint256" },
    ],
};

const signature = await wallet._signTypedData(domain, types, authorization);
```

**Step 3: Include in Transaction**
```javascript
// Add to SetCodeTx
const tx = {
    type: 4, // SetCodeTxType
    authorizationList: [{
        chainId: authorization.chainId,
        address: authorization.address,
        nonce: authorization.nonce,
        ...ethers.utils.splitSignature(signature)
    }],
    // ... other transaction fields
};
```

### Delegation Validation Rules

**Source:** [`x/vm/keeper/state_transition.go:563-591`](https://github.com/cosmos/evm/blob/main/x/vm/keeper/state_transition.go#L563-591)

1. **Chain ID Validation:** Authorization chain ID must match or be zero
2. **Nonce Validation:** Authorization nonce must match current account nonce  
3. **Account State:** Authority account must be EOA or have existing delegation
4. **Signature Validation:** Authorization signature must be valid
5. **Nonce Increment:** Authority nonce incremented after authorization

```go
// Validation implementation
func (k *Keeper) validateAuthorization(auth *SetCodeAuthorization, state vm.StateDB, chainID *big.Int) (common.Address, error) {
    // 1. Verify chain ID
    if !auth.ChainID.IsZero() && auth.ChainID.CmpBig(chainID) != 0 {
        return authority, core.ErrAuthorizationWrongChainID
    }
    
    // 2. Verify nonce bounds
    if auth.Nonce+1 < auth.Nonce {
        return authority, core.ErrAuthorizationNonceOverflow
    }
    
    // 3. Recover authority from signature
    authority, err := auth.Authority()
    if err != nil {
        return authority, fmt.Errorf("%w: %v", core.ErrAuthorizationInvalidSignature, err)
    }
    
    // 4. Validate account state
    code := state.GetCode(authority)
    if _, ok := ethtypes.ParseDelegation(code); len(code) != 0 && !ok {
        return authority, core.ErrAuthorizationDestinationHasCode
    }
    
    // 5. Validate nonce matches
    if have := state.GetNonce(authority); have != auth.Nonce {
        return authority, core.ErrAuthorizationNonceMismatch
    }
    
    return authority, nil
}
```

### Code Delegation Mechanism

**Source:** [`x/vm/keeper/state_transition.go:536-561`](https://github.com/cosmos/evm/blob/main/x/vm/keeper/state_transition.go#L536-561)

```go
// Apply authorization - sets delegation code
func (k *Keeper) applyAuthorization(auth *SetCodeAuthorization, state vm.StateDB, chainID *big.Int) error {
    authority, err := k.validateAuthorization(auth, state, chainID)
    if err != nil {
        return err
    }
    
    // Refund gas if account exists
    if state.Exist(authority) {
        state.AddRefund(params.CallNewAccountGas - params.TxAuthTupleGas)
    }
    
    // Update nonce
    state.SetNonce(authority, auth.Nonce+1, tracing.NonceChangeAuthorization)
    
    if auth.Address == (common.Address{}) {
        // Clear delegation
        state.SetCode(authority, nil)
        return nil
    }
    
    // Set delegation code
    state.SetCode(authority, ethtypes.AddressToDelegation(auth.Address))
    return nil
}
```

### Delegation Bytecode Format

**Delegation Code Structure:**
```
0xef0100 + 20-byte contract address

Example:
Original Contract: 0x1234567890123456789012345678901234567890
Delegation Code:   0xef01001234567890123456789012345678901234567890
```

**Parsing Implementation:**
```go
// Source: go-ethereum ethtypes.ParseDelegation
func ParseDelegation(code []byte) (common.Address, bool) {
    if len(code) == 23 && code[0] == 0xef && code[1] == 0x01 && code[2] == 0x00 {
        return common.BytesToAddress(code[3:]), true
    }
    return common.Address{}, false
}
```

## Gas Costs and Economics

### Gas Cost Parameters

| Operation | Gas Cost | Source |
|-----------|----------|---------|
| **Authorization Tuple** | 12500 gas | `params.TxAuthTupleGas` |
| **New Account Creation** | 25000 gas | `params.CallNewAccountGas` |
| **Refund (Existing Account)** | 12500 gas | Difference refunded |
| **Code Execution** | Standard | Same as contract calls |

### Gas Optimization

```javascript
// Optimize gas usage with authorizations
async function optimizedDelegation() {
    // 1. Authorize existing account (gets refund)
    const existingAccount = "0x..."; // Account that already exists
    
    // 2. Use minimal authorization list
    const authList = [{
        chainId: 9000,
        address: contractAddress,
        nonce: await provider.getTransactionCount(existingAccount),
    }];
    
    // 3. Gas cost calculation
    const baseCost = 21000;                    // Base transaction cost
    const authCost = 12500 * authList.length; // Authorization cost
    const refund = 12500;                      // Refund for existing account
    const executionCost = 50000;               // Contract execution cost
    
    const totalGas = baseCost + authCost - refund + executionCost;
    console.log("Estimated gas:", totalGas);
}
```

## Advanced Use Cases

### Multi-Signature Wallet via Delegation

```solidity
// Multi-sig wallet contract for delegation
contract MultiSigWallet {
    mapping(address => mapping(bytes32 => uint256)) public confirmations;
    mapping(address => address[]) public signers;
    mapping(address => uint256) public required;
    
    function executeMultiSig(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 txHash,
        bytes[] calldata signatures
    ) external {
        require(msg.sender == tx.origin, "Must be called via delegation");
        
        // Verify signatures
        address[] memory walletSigners = signers[tx.origin];
        require(signatures.length >= required[tx.origin], "Insufficient signatures");
        
        uint256 validSignatures = 0;
        for (uint256 i = 0; i < signatures.length; i++) {
            address signer = recover(txHash, signatures[i]);
            if (isValidSigner(walletSigners, signer)) {
                validSignatures++;
            }
        }
        
        require(validSignatures >= required[tx.origin], "Invalid signatures");
        
        // Execute transaction
        (bool success, ) = target.call{value: value}(data);
        require(success, "Transaction failed");
    }
}
```

### Time-Locked Wallet

```solidity
// Time-locked wallet with emergency features
contract TimeLockWallet {
    struct TimeLock {
        uint256 amount;
        uint256 unlockTime;
        address recipient;
    }
    
    mapping(address => TimeLock[]) public timeLocks;
    mapping(address => address) public emergencyContacts;
    
    function createTimeLock(
        uint256 amount,
        uint256 lockDuration,
        address recipient
    ) external {
        require(msg.sender == tx.origin, "Must be delegated");
        
        timeLocks[tx.origin].push(TimeLock({
            amount: amount,
            unlockTime: block.timestamp + lockDuration,
            recipient: recipient
        }));
    }
    
    function executeTimeLock(uint256 index) external {
        TimeLock memory lock = timeLocks[tx.origin][index];
        require(block.timestamp >= lock.unlockTime, "Still locked");
        
        payable(lock.recipient).transfer(lock.amount);
        
        // Remove executed lock
        delete timeLocks[tx.origin][index];
    }
    
    function emergencyRecovery() external {
        require(msg.sender == emergencyContacts[tx.origin], "Unauthorized");
        // Emergency recovery logic...
    }
}
```

### DeFi Strategy Automation

```solidity
// Automated DeFi strategy executor
contract DeFiAutomator {
    struct Strategy {
        address[] protocols;
        uint256[] allocations;
        uint256 rebalanceThreshold;
        uint256 lastRebalance;
    }
    
    mapping(address => Strategy) public strategies;
    
    function executeStrategy(
        address[] calldata swapTargets,
        bytes[] calldata swapData,
        uint256[] calldata amounts
    ) external {
        require(msg.sender == tx.origin, "Must be delegated");
        
        Strategy memory strategy = strategies[tx.origin];
        require(strategy.protocols.length > 0, "No strategy configured");
        
        // Execute complex DeFi operations
        for (uint256 i = 0; i < swapTargets.length; i++) {
            (bool success, ) = swapTargets[i].call(swapData[i]);
            require(success, "Swap failed");
        }
        
        // Update strategy state
        strategies[tx.origin].lastRebalance = block.timestamp;
    }
    
    function autoRebalance() external view returns (bool shouldRebalance) {
        Strategy memory strategy = strategies[tx.origin];
        return block.timestamp >= strategy.lastRebalance + 1 days;
    }
}
```

## Security Considerations

### Authorization Security

**Nonce Management:**
```javascript
// Always use current nonce for authorization
const currentNonce = await provider.getTransactionCount(authorizer);
const authorization = {
    chainId: 9000,
    address: contractAddress,
    nonce: currentNonce, // CRITICAL: Must match exactly
};
```

**Chain ID Validation:**
```javascript
// Specify chain ID to prevent cross-chain replay
const authorization = {
    chainId: 9000, // Specific chain (not 0)
    address: contractAddress,
    nonce: currentNonce,
};
```

### Common Security Patterns

**1. Authority Verification:**
```solidity
contract SecureDelegatedContract {
    function sensitiveOperation() external {
        require(msg.sender == tx.origin, "Must be called via delegation");
        require(authorizedUsers[tx.origin], "User not authorized");
        // ... secure operation
    }
}
```

**2. Reentrancy Protection:**
```solidity
contract ReentrancyProtected {
    mapping(address => bool) private locked;
    
    modifier nonReentrant() {
        require(!locked[tx.origin], "Reentrant call");
        locked[tx.origin] = true;
        _;
        locked[tx.origin] = false;
    }
    
    function delegatedFunction() external nonReentrant {
        // Protected function
    }
}
```

## Testing and Debugging

### Test Suite

**Benchmark Tests:** [`tests/integration/x/vm/state_transition_benchmark.go`](https://github.com/cosmos/evm/blob/main/tests/integration/x/vm/state_transition_benchmark.go)

```bash
# Run EIP-7702 specific tests
cd /path/to/cosmos-evm
go test -v -run ".*SetCode.*" ./tests/integration/x/vm/
```

### Debugging Failed Authorizations

**Common Errors and Solutions:**

1. **`ErrAuthorizationWrongChainID`**
   ```javascript
   // Fix: Use correct chain ID or 0 for any chain
   const authorization = { chainId: 9000, ... }; // Not 1 (Ethereum mainnet)
   ```

2. **`ErrAuthorizationNonceMismatch`**  
   ```javascript
   // Fix: Use current nonce exactly
   const nonce = await provider.getTransactionCount(authorizer);
   const authorization = { nonce, ... };
   ```

3. **`ErrAuthorizationDestinationHasCode`**
   ```javascript
   // Fix: Only authorize EOAs or accounts with existing delegations
   const code = await provider.getCode(authority);
   if (code !== "0x") {
       console.log("Account already has code - cannot authorize");
   }
   ```

### Transaction Tracing

```bash
# Trace SetCode transaction execution
evmd query vm trace-tx 0x[SetCodeTxHash] --trace-type json

# Debug authorization validation
curl -X POST \
  -H "Content-Type: application/json" \
  --data '{
    "jsonrpc":"2.0",
    "method":"debug_traceTransaction", 
    "params":["0x[SetCodeTxHash]", {"tracer": "callTracer"}],
    "id":1
  }' \
  http://localhost:8545
```

## Comparison with Account Abstraction

### EIP-7702 vs EIP-4337 (Account Abstraction)

| Feature | EIP-7702 | EIP-4337 |
|---------|----------|----------|
| **Compatibility** | Works with existing EOAs | Requires new account type |
| **Infrastructure** | Standard transaction flow | Requires bundler infrastructure |
| **Gas Efficiency** | Direct execution | Additional bundler overhead |
| **Flexibility** | Temporary delegation | Permanent smart account |
| **Adoption** | Immediate EOA enhancement | New account creation needed |

### EIP-7702 Benefits

- **Backward Compatibility:** Existing EOAs can be enhanced without migration
- **Immediate Adoption:** No new infrastructure required
- **Lower Overhead:** Direct transaction execution vs. bundler complexity
- **Cosmos Integration:** Works seamlessly with IBC and Cosmos SDK features

## References

- **EIP-7702 Specification:** https://eips.ethereum.org/EIPS/eip-7702
- **Implementation PRs:**
  - [Core Implementation](https://github.com/cosmos/evm/commit/4b0dcd3e) (July 2025)
  - [Ante Handler Support](https://github.com/cosmos/evm/commit/2cc93849) (July 2025)  
  - [RPC Integration](https://github.com/cosmos/evm/commit/9164b471) (July 2025)
- **Source Code:**
  - [`x/vm/keeper/state_transition.go:426+`](https://github.com/cosmos/evm/blob/main/x/vm/keeper/state_transition.go#L426) - Core delegation logic
  - [`ante/evm/06_account_verification.go:33+`](https://github.com/cosmos/evm/blob/main/ante/evm/06_account_verification.go#L33) - Authorization validation
  - [`rpc/types/utils.go:322+`](https://github.com/cosmos/evm/blob/main/rpc/types/utils.go#L322) - RPC transaction formatting