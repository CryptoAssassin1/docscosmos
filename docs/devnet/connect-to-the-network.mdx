---
title: 'Connect to the Network'
description: 'This page provides general information to help you connect to the network and get started building.'
---

## Chain Info

| Info | Value | Purpose |
|-------------------|----------------------|---------|
| **Cosmos Chain ID** | `4321` | Network Identifier for Cosmos tooling |
| **EVM Chain ID** | `4231` | Network identifier for EVM tooling |
| **EVM Version** | `Istanbul` | EVM hard fork compatibility version |
| **Native Token** | `ATOM` | Staking / gas token |
| **Denom Exponent** | `6` | Native token has 6 decimal places (`uatom`) |

## Public Endpoints

| Endpoint | Value | Purpose |
|-------------------|----------------------|---------|
| **EVM JSON-RPC** | `https://devnet-1-evmrpc.ib.skip.build` | Ethereum-compatible tools (MetaMask, Hardhat, ethers.js) |
| **EVM RPC WS**   | `wss://devnet-1-evmws.ib.skip.build`   | Streaming real-time, selective data for applications |
| **Cosmos RPC** | `https://devnet-1-rpc.ib.skip.build` | Tendermint-level interactions (blocks, consensus state) |
| **Cosmos REST API** | `https://devnet-1-lcd.ib.skip.build` | Query Cosmos SDK modules (bank, staking, etc.) |
| **gRPC** | `devnet-1-grpc.ib.skip.build:443` | High-performance Protobuf endpoint for back-ends |

## How to Interact with the Chain

You can interact with the Gaia EVM Devnet in several different ways. This section provides a brief overview of how to setup the various environments for testing.

### Extension-Based Wallets

To test out your dApp via a web UI using an extension-based wallet, you'll need to first add the Gaia EVM Devnet to the wallet like so:

1. Install [Keplr](https://www.keplr.app/), [Metamask](https://metamask.io/) or [Rabby](https://rabby.io/) (Chrome/Mobile).
2. Add a custom network:
    - Chain ID: `4321`
    - RPC URL: `https://devnet-1-rpc.ib.skip.build`
    - Chain Name: `Skip Devnet`
    - Currency Symbol: `ATOM`
    - Currency Decimals: `6`
3. Use the UI to send tokens, view balances, and interact with dApps.

### CLI

Using the CLI may be a great choice for one-off tasks and queries that do not require a full node. **Make sure you use a binary built from the `feature/evm` branch of Gaia, which contains the EVM module used on this devnet.**

```bash
# Option A — download a pre-built artifact (feature/evm branch)
VERSION=v9.0.0-evm           # example tag built from feature/evm
curl -LO "https://github.com/cosmos/gaia/releases/download/${VERSION}/gaiad_${VERSION}_linux_amd64.tar.gz"

tar -xzf gaiad_${VERSION}_linux_amd64.tar.gz
chmod +x gaiad && sudo mv gaiad /usr/local/bin/

# Option B — build from source
# (requires Go ≥ 1.22)
git clone --branch feature/evm https://github.com/cosmos/gaia.git
cd gaia && make install   # installs gaiad into $(go env GOPATH)/bin
```

#### Key Management & HD Paths

Gaia (feature/evm) supports *two* key algorithms:

| Algo flag | HD Path | Typical address format | Use-case |
|-----------|---------|------------------------|----------|
| `eth_secp256k1` *(default)* | `m/44'/60'/0'/0/0` | `0x…` / `cosmos1…` | **Recommended for EVM dApps** – interoperable with MetaMask & hard-fork compatible |
| `secp256k1` | `m/44'/118'/0'/0/0` | `cosmos1…` | Classic Cosmos wallets |

When you recover a mnemonic exported for EVM use, be sure to keep the algorithm & path consistent:

```bash
# create a new EVM-compatible key
$ gaiad keys add myevmkey                    # default is --algo eth_secp256k1

# recover an existing 24-word mnemonic *and* force the EVM path
$ gaiad keys add user10 --recover \
           --algo eth_secp256k1 \
           --hd-path "m/44'/60'/0'/0/0"
```

If you omit the flags the CLI may derive the Cosmos HD path (m/44/118/…), producing a different `cosmos1…` address – exactly what happened in the user report quoted below.

> **Why two addresses?**  The same 256-bit private key can generate *both* a Cosmos (`secp256k1`) and Ethereum (`eth_secp256k1`) address.  The devnet faucets and precompiles expect the Ethereum-style address for full EVM compatibility.

<AccordionGroup>
  <Accordion title="Query Examples">
    <CodeGroup>
      ```bash Query balances for a given address
      gaiad q bank balances cosmos1... --node https://devnet-1-rpc.ib.skip.build:443
      ```

      ```bash Query the list of validators
      gaiad q staking validators --node https://devnet-1-rpc.ib.skip.build:443
      ```
    </CodeGroup>
  </Accordion>

  <Accordion title="Broadcast a Transaction">
    <CodeGroup>
      ```bash Example
      gaiad tx bank send cosmos1... cosmos1... 1000uatom \
        --node https://devnet-1-rpc.ib.skip.build:443 \
        --chain-id 4321 \
        --gas auto --fees 500uatom \
        --yes
      ```
    </CodeGroup>
  </Accordion>

  <Accordion title="Generate Transaction Messages">
    You can use the `--generate-only` flag to create transaction messages without broadcasting them. This can be useful for finding the correct syntax and creating reusable transaction templates.

    | Field (0x02)          | Value         |
    | --------------------- | ------------- |
    | **chainId**           | `0x01`        |
    | **nonce**             | `0x`          |
    | **maxPrioFeePerGas**  | `0x01`        |
    | **maxFeePerGas**      | `0x01`        |
    | **gasLimit**          | `0x5208`      |
    | **to / value / data** | same as above |
    | **accessList**        | `[]`          |
    | **yParity (v)**       | `0x0`         |
    | **r**, **s**          | `0x0`, `0x0`  |

    <CodeGroup>
      ```bash Example
      evmd tx evm raw 0x02e20180010182520894de0b295669a9fd93d5f28d9ec85e40f4cb697bae8080c0808080 --generate-only | jq
      ```

      ```json Example output
      {
        "body": {
          "messages": [
            {
              "@type": "/cosmos.evm.vm.v1.MsgEthereumTx",
              "data": {
                "@type": "/cosmos.evm.vm.v1.DynamicFeeTx",
                "chain_id": "1",
                "nonce": "0",
                "gas_tip_cap": "1",
                "gas_fee_cap": "1",
                "gas": "21000",
                "to": "0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe",
                "value": "0",
                "data": null,
                "accesses": [],
                "v": null,
                "r": null,
                "s": null
              },
              "size": 0,
              "hash": "0x10c35e9f591e43bac6a9d01164a62e141d16ca715653ac818761c79e3eecafbc",
              "from": ""
            }
          ],
          "memo": "",
          "timeout_height": "0",
          "unordered": false,
          "timeout_timestamp": null,
          "extension_options": [
            {
              "@type": "/cosmos.evm.vm.v1.ExtensionOptionsEthereumTx"
            }
          ],
          "non_critical_extension_options": []
        },
        "auth_info": {
          "signer_infos": [],
          "fee": {
            "amount": [
              {
                "denom": "atest",
                "amount": "21000"
              }
            ],
            "gas_limit": "21000",
            "payer": "",
            "granter": ""
          },
          "tip": null
        },
        "signatures": []
      }
      ```
    </CodeGroup>
  </Accordion>

</AccordionGroup>

### REST (LCD) Endpoints

> **Use for HTTP-based integrations**

Cosmos SDK chains expose a REST API at port `1317` by default. For the devnet:

`https://devnet-1-lcd.ib.skip.build`

Basic endpoints:

* `GET /cosmos/bank/v1beta1/balances/{address}`
* `POST /cosmos/tx/v1beta1/txs` (broadcast)

Refer to the [OpenAPI spec](https://api.cosmos.network/) for details.

### EVM JSON-RPC Endpoints

> **For Ethereum-compatible tooling**

Connect your Ethereum tools to the EVM module:

```
RPC:       https://devnet-1-evmrpc.ib.skip.build
WebSocket: wss://devnet-1-evmws.ib.skip.build
Chain ID:  4321 (0x10e1)
```

Use with MetaMask, Hardhat, Foundry, or any Ethereum-compatible client.

## Connecting to the Network

### Using Remote Endpoints

The `evmd` CLI tool and other clients require a connection to the network in order to interact with the chain.

**Method 1 — configure `evmd`**

Edit `~/.evmd/config/client.toml`:

```toml title="~/.evmd/config/client.toml"
# ~/.evmd/config/client.toml
node = "https://devnet-1-rpc.ib.skip.build"
```

All subsequent `evmd` commands use the remote node:

```sh lines
evmd q bank balances $(evmd keys show <wallet_name> --address)
```

**Method 2 — API**

Applications typically interact with the network programmatically using the EVM JSON-RPC, in addition to the standard Cosmos GRPC/REST API. Below are some basic examples of various common usecases:

For a complete list of available endpoints and methods, see the [API Reference](./api-reference) documentation.

#### EVM JSON-RPC

```js lines expandable
import { ethers } from "ethers";

const provider = new ethers.JsonRpcProvider("https://devnet-1-evmrpc.ib.skip.build");
const balance = await provider.getBalance("0x...");
```

#### Cosmos REST API

```sh lines
curl https://devnet-1-lcd.ib.skip.build/cosmos/staking/v1beta1/params
```

#### EVM JSON-RPC — **Python (web3.py)**

```python lines expandable
from web3 import Web3

provider = Web3(Web3.HTTPProvider("https://devnet-1-evmrpc.ib.skip.build"))

address = "0xYourAddress"
balance_wei = provider.eth.get_balance(address)
balance_eth = Web3.from_wei(balance_wei, "ether")

print(f"Balance: {balance_eth} DEV")
```

#### Cosmos REST API — **Python (requests)**

```python lines expandable
import requests

resp = requests.get(
    "https://devnet-1-lcd.ib.skip.build/cosmos/staking/v1beta1/params",
    timeout=10,
)
print(resp.json())
```

```go lines expandable
package main

import (
    "context"
    "fmt"
    "log"
    "math/big"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    client, err := ethclient.Dial("https://devnet-1-evmrpc.ib.skip.build")
    if err != nil {
        log.Fatal(err)
    }

    address := common.HexToAddress("0xYourAddress")
    balance, err := client.BalanceAt(context.Background(), address, nil)
    if err != nil {
        log.Fatal(err)
    }

    ethValue := new(big.Float).Quo(
        new(big.Float).SetInt(balance),
        big.NewFloat(1e18),
    )

    fmt.Printf("Balance: %s DEV\n", ethValue)
}
```

```go lines expandable
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
)

func main() {
    resp, err := http.Get("https://devnet-1-lcd.ib.skip.build/cosmos/bank/v1beta1/balances/cosmos1youraddresshere")
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close()

    var result map[string]interface{}
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        log.Fatal(err)
    }

    pretty, _ := json.MarshalIndent(result, "", "  ")
    fmt.Println(string(pretty))
}
```