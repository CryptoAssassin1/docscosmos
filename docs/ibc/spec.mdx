---
title: "Core Protocol Spec"
description: "The foundation of the Inter-Blockchain Communication Protocol"
---
<footnote>
For legacy IBC implementations, refer to the [IBC‑go docs](https://ibc.cosmos.network/main/).
</footnote>

import { footnote } from '/snippets/footnote.mdx'


The latest version of Inter‑Blockchain Communication Protocol (**IBC**) enables token transfers across multiple blockchain environments through a standard set of components, interfaces, and a defined packet flow.


### Core Data Structures

The **`Packet`** is the primary container for cross-chain communication. Each packet wraps one or more application-specific **`Payload`** objects.

<CodeGroup>

```typescript packet.ts
// The main data container sent between chains
interface Packet {
  sourceClientId: bytes; // Client ID for destination chain (stored on source)
  destClientId: bytes;   // Client ID for source chain (stored on destination)
  sequence: uint64;      // Monotonically increasing nonce for ordering
  timeoutTimestamp: uint64; // UNIX timestamp (seconds) when the packet expires
  data: Payload[];       // List of application payloads
}

// Application-specific data and routing information
interface Payload {
sourcePort: bytes; // Identifies sending application module
destPort: bytes;   // Identifies receiving application module
version: string;   // App-specific version for interpretation
encoding: string;  // MIME-type for decoding value
value: bytes;    // Opaque application data
}

```

```json packet.json
{
  "sourceClientId": "07-tendermint-0",
  "destClientId": "07-tendermint-0",
  "sequence": 1,
  "timeoutTimestamp": 1617348393,
  "data": [
    {
      "sourcePort": "transfer",
      "destPort": "transfer",
      "version": "ics20-1",
      "encoding": "application/json",
      "value": "<base64-encoded application data>"
    }
  ]
}
```

</CodeGroup>


## Key Components

<Accordion title="Client (ICS‑02) – Light Client">
An on‑chain light client that verifies the state of a counter‑party chain using cryptographic proofs against a trusted consensus state.

**Primary entry points**

* `createClient`
* `updateClient`
* `verifyMembership`
* `verifyNonMembership`

</Accordion>

<Accordion title="Provable Store (ICS‑24)">
A Merkle‑proof‑capable key‑value store required on the host chain. Standardized paths enable verification by counter‑party chains.

| Value             | Path Format                                    |
| :---------------- | :--------------------------------------------- |
| Packet Commitment | `{sourceClientId}0x1{bigEndianUint64Sequence}` |
| Packet Receipt    | `{destClientId}0x2{bigEndianUint64Sequence}`   |
| Acknowledgement   | `{destClientId}0x3{bigEndianUint64Sequence}`   |

</Accordion>

<Accordion title="Port Allocation (ICS‑05)">
Applications must bind to unique **`portId`** values during initialization. The port is referenced in every `Payload` to route incoming packets.
</Accordion>

### Application Callbacks (ICS-26)

An IBC-enabled application **must** implement these callbacks. The IBC handler provides key identifiers like client IDs and the packet sequence so the application has the full context for every call.

  * **`OnRecvPacket(sourceClientId, destClientId, sequence, payload)`** – Executed on the **destination chain** to process incoming data. It must return an **Acknowledgement** (success or error).
  * **`OnAcknowledgePacket(sourceClientId, destClientId, sequence, payload, acknowledgement)`** – Executed on the **source chain** once an acknowledgement is verified, finalizing or compensating the originating action.
  * **`OnTimeoutPacket(sourceClientId, destClientId, sequence, payload)`** – Executed on the **source chain** if no acknowledgement is received before `timeoutTimestamp`, allowing rollback or refunds.

<Warning>For packets with multiple payloads, execution is **atomic**. If the `OnRecvPacket` callback fails for even one payload, the entire packet operation is considered a failure. Any state changes from other successful callbacks in the same packet **must be reverted**.</Warning>



## Packet Lifecycle

The end‑to‑end flow from send to completion involves five discrete steps. Expand any step below for details.

<Accordion title="1. SendPacket (Source Chain)">
The sending application submits one or more `Payload` objects. The IBC handler wraps them in a `Packet`, assigns a new **sequence** number, and stores a cryptographic commitment at the **Packet Commitment** path.
</Accordion>

<Accordion title="2. RecvPacket (Destination Chain)">
A relayer delivers the `Packet` together with a proof of its commitment. The destination chain’s IBC handler:

1. Locates the correct light client via `destClientId`.
2. Verifies the proof.
3. Stores a **Receipt** at the **Packet Receipt** path.
4. Invokes the destination module’s `OnRecvPacket` callback.

</Accordion>

<Accordion title="3. WriteAcknowledgement (Destination Chain)">
The destination application returns an **Acknowledgement** (success data or error) from `OnRecvPacket`. The IBC handler commits this acknowledgement at the **Acknowledgement** path, making it ava>

For applications with long-running logic, this process can be asynchronous. The app can process the packet later and call a separate `WriteAcknowledgement` function to submit the result.
</Accordion>

<Accordion title="4. AcknowledgePacket (Source Chain)">
A relayer brings the acknowledgement and its proof back to the source chain. After proof verification, the source chain’s handler:

* Deletes the original packet commitment.
* Calls `OnAcknowledgePacket` on the sending application to finalize the cross‑chain operation.

</Accordion>

<Accordion title="5. TimeoutPacket (Source Chain)">
If no acknowledgement arrives before `timeout`, a relayer submits a non‑existence proof for the **Packet Receipt**. The source chain deletes the packet commitment and triggers `OnTimeoutPacket`, allowing the application to revert or refund the original transaction.
</Accordion>
