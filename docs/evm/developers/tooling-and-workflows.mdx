---
title: "Foundry & Hardhat Workflows"
description: "Master the essential development tools and workflows for building on Cosmos EVM with practical examples and best practices."
---

The Cosmos EVM supports the complete Ethereum development ecosystem, enabling you to use familiar tools like Foundry and Hardhat with their full feature sets. This guide covers practical workflows, configuration, and best practices specific to Cosmos EVM development.

## Tool Selection Guide

Choose your development framework based on your project needs and team preferences:

<CardGroup cols={2}>
  <Card title="Foundry" icon="hammer">
    **Best for:** Performance-critical projects, advanced testing, Rust developers

    **Strengths:**
    - Blazing fast compilation and testing
    - Solidity-native testing with advanced features
    - Built-in fuzzing and invariant testing
    - Excellent gas profiling and optimization tools
  </Card>

  <Card title="Hardhat" icon="wrench">
    **Best for:** Teams with JavaScript/TypeScript expertise, complex deployment workflows

    **Strengths:**
    - Rich plugin ecosystem
    - Flexible TypeScript integration
    - Advanced debugging capabilities
    - Extensive community resources
  </Card>
</CardGroup>

## Foundry Workflows

### Project Setup and Configuration

Initialize a new Foundry project optimized for Cosmos EVM:

```bash
# Create new project
forge init cosmos-evm-project
cd cosmos-evm-project

# Install dependencies
forge install openzeppelin/openzeppelin-contracts
forge install foundry-rs/forge-std
```

Configure `foundry.toml` for Cosmos EVM development:

```toml
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc_version = "0.8.24"
optimizer = true
optimizer_runs = 200
via_ir = false

# Cosmos EVM specific settings
evm_version = "cancun"
gas_limit = 30000000
gas_price = 20000000000

[rpc_endpoints]
local = "http://localhost:8545"
testnet = "${COSMOS_EVM_TESTNET_RPC}"
mainnet = "${COSMOS_EVM_MAINNET_RPC}"

[etherscan]
cosmos_evm_testnet = { key = "${ETHERSCAN_API_KEY}", url = "https://testnet-explorer.cosmos-evm.org/api" }
```

### Smart Contract Development

Create a sample contract that leverages Cosmos EVM's unique features:

```solidity
// src/CosmosEVMExample.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// Interface for the staking precompile
interface IStaking {
    function delegate(address validator, uint256 amount) external returns (bool);
    function undelegate(address validator, uint256 amount) external returns (bool, uint64);
    function claimRewards(address validator) external returns (bool, uint256);
}

contract LiquidStakingVault is Ownable, ReentrancyGuard {
    IStaking constant STAKING = IStaking(0x0000000000000000000000000000000000000800);

    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public liquidTokens;

    address public primaryValidator;
    uint256 public totalStaked;
    uint256 public totalLiquidTokens;

    event Staked(address indexed user, uint256 amount, uint256 liquidTokens);
    event Unstaked(address indexed user, uint256 amount, uint256 liquidTokens);

    constructor(address _primaryValidator) Ownable(msg.sender) {
        primaryValidator = _primaryValidator;
    }

    function stake() external payable nonReentrant {
        require(msg.value > 0, "Must stake positive amount");

        // Delegate to validator through precompile
        bool success = STAKING.delegate(primaryValidator, msg.value);
        require(success, "Delegation failed");

        // Calculate liquid tokens (1:1 for simplicity)
        uint256 liquidAmount = msg.value;

        stakedBalance[msg.sender] += msg.value;
        liquidTokens[msg.sender] += liquidAmount;
        totalStaked += msg.value;
        totalLiquidTokens += liquidAmount;

        emit Staked(msg.sender, msg.value, liquidAmount);
    }

    function unstake(uint256 liquidAmount) external nonReentrant {
        require(liquidTokens[msg.sender] >= liquidAmount, "Insufficient liquid tokens");

        // Undelegate from validator
        (bool success,) = STAKING.undelegate(primaryValidator, liquidAmount);
        require(success, "Undelegation failed");

        liquidTokens[msg.sender] -= liquidAmount;
        stakedBalance[msg.sender] -= liquidAmount;
        totalLiquidTokens -= liquidAmount;
        totalStaked -= liquidAmount;

        emit Unstaked(msg.sender, liquidAmount, liquidAmount);
    }

    function claimStakingRewards() external onlyOwner {
        STAKING.claimRewards(primaryValidator);
        // Additional logic to distribute rewards to liquid token holders
    }
}
```

### Testing with Foundry

Create comprehensive tests that cover Cosmos EVM specific functionality:

```solidity
// test/LiquidStakingVault.t.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../src/CosmosEVMExample.sol";

contract LiquidStakingVaultTest is Test {
    LiquidStakingVault public vault;
    address public validator = 0x1234567890123456789012345678901234567890;
    address public user1 = address(0x1);
    address public user2 = address(0x2);

    function setUp() public {
        vault = new LiquidStakingVault(validator);

        // Fund test accounts
        vm.deal(user1, 10 ether);
        vm.deal(user2, 5 ether);

        // Mock the staking precompile
        vm.mockCall(
            address(0x0000000000000000000000000000000000000800),
            abi.encodeWithSelector(IStaking.delegate.selector),
            abi.encode(true)
        );

        vm.mockCall(
            address(0x0000000000000000000000000000000000000800),
            abi.encodeWithSelector(IStaking.undelegate.selector),
            abi.encode(true, uint64(block.timestamp + 21 days))
        );
    }

    function testStaking() public {
        vm.startPrank(user1);

        uint256 stakeAmount = 1 ether;
        vault.stake{value: stakeAmount}();

        assertEq(vault.stakedBalance(user1), stakeAmount);
        assertEq(vault.liquidTokens(user1), stakeAmount);
        assertEq(vault.totalStaked(), stakeAmount);

        vm.stopPrank();
    }

    function testUnstaking() public {
        // First stake
        vm.prank(user1);
        vault.stake{value: 1 ether}();

        // Then unstake
        vm.prank(user1);
        vault.unstake(0.5 ether);

        assertEq(vault.liquidTokens(user1), 0.5 ether);
        assertEq(vault.stakedBalance(user1), 0.5 ether);
    }

    function testFuzzStaking(uint256 amount) public {
        vm.assume(amount > 0 && amount <= 100 ether);

        vm.deal(user1, amount);
        vm.prank(user1);
        vault.stake{value: amount}();

        assertEq(vault.stakedBalance(user1), amount);
    }
}
```

### Deployment and Verification

Create deployment scripts for different networks:

```solidity
// script/Deploy.s.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Script.sol";
import "../src/CosmosEVMExample.sol";

contract DeployScript is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address validator = vm.envAddress("VALIDATOR_ADDRESS");

        vm.startBroadcast(deployerPrivateKey);

        LiquidStakingVault vault = new LiquidStakingVault(validator);
        console.log("LiquidStakingVault deployed to:", address(vault));

        vm.stopBroadcast();
    }
}
```

Deploy to local testnet:

```bash
# Start local Cosmos EVM node first
./local_node.sh

# Deploy contract
forge script script/Deploy.s.sol:DeployScript \
  --rpc-url http://localhost:8545 \
  --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 \
  --broadcast

# Verify deployment
forge verify-contract \
  --rpc-url http://localhost:8545 \
  --constructor-args $(cast abi-encode "constructor(address)" "0x1234567890123456789012345678901234567890") \
  0x... \
  src/CosmosEVMExample.sol:LiquidStakingVault
```

## Hardhat Workflows

### Project Setup and Configuration

Initialize and configure a Hardhat project for Cosmos EVM:

```bash
mkdir cosmos-evm-hardhat
cd cosmos-evm-hardhat
npm init -y
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox @openzeppelin/contracts
npx hardhat init
```

Configure `hardhat.config.js` for Cosmos EVM networks:

```javascript
require("@nomicfoundation/hardhat-toolbox");
require("dotenv").config();

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: {
    version: "0.8.24",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
      evmVersion: "cancun"
    },
  },
  networks: {
    local: {
      url: "http://127.0.0.1:8545",
      chainId: 9000,
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      gasPrice: 20000000000,
      gas: 30000000,
    },
    testnet: {
      url: process.env.COSMOS_EVM_TESTNET_RPC || "",
      chainId: 9001, // Example testnet chain ID
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      gasPrice: "auto",
      gas: "auto",
    }
  },
  gasReporter: {
    enabled: true,
    currency: "USD",
    gasPrice: 20
  },
  etherscan: {
    apiKey: {
      cosmosEvmTestnet: process.env.ETHERSCAN_API_KEY || "dummy"
    },
    customChains: [
      {
        network: "cosmosEvmTestnet",
        chainId: 9001,
        urls: {
          apiURL: "https://testnet-explorer.cosmos-evm.org/api",
          browserURL: "https://testnet-explorer.cosmos-evm.org"
        }
      }
    ]
  }
};
```

### TypeScript Integration

Create type-safe contracts with full TypeScript integration:

```typescript
// contracts/interfaces/IStaking.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IStaking {
    function delegate(address validator, uint256 amount) external returns (bool);
    function undelegate(address validator, uint256 amount) external returns (bool, uint64);
    function claimRewards(address validator) external returns (bool, uint256);
    function delegation(address delegator, address validator) external view returns (uint256);
}
```

```typescript
// test/LiquidStakingVault.test.ts
import { expect } from "chai";
import { ethers } from "hardhat";
import { LiquidStakingVault, IStaking } from "../typechain-types";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";

describe("LiquidStakingVault", function () {
  let vault: LiquidStakingVault;
  let owner: SignerWithAddress;
  let user1: SignerWithAddress;
  let user2: SignerWithAddress;

  const STAKING_PRECOMPILE = "0x0000000000000000000000000000000000000800";
  const VALIDATOR_ADDRESS = "0x1234567890123456789012345678901234567890";

  beforeEach(async function () {
    [owner, user1, user2] = await ethers.getSigners();

    const VaultFactory = await ethers.getContractFactory("LiquidStakingVault");
    vault = await VaultFactory.deploy(VALIDATOR_ADDRESS);
    await vault.waitForDeployment();

    // Mock the staking precompile
    await ethers.provider.send("hardhat_setCode", [
      STAKING_PRECOMPILE,
      "0x6080604052348015600f57600080fd5b506004361060285760003560e01c80635c19a95c14602d575b600080fd5b60436038366004606b565b600160405190815260200160405180910390f35b60405190151581526020015b60405180910390f35b600080fd5b600060208284031215607c57600080fd5b81356001600160a01b0381168114609257600080fd5b9392505050565b"
    ]);
  });

  it("Should allow staking and mint liquid tokens", async function () {
    const stakeAmount = ethers.parseEther("1.0");

    await expect(vault.connect(user1).stake({ value: stakeAmount }))
      .to.emit(vault, "Staked")
      .withArgs(user1.address, stakeAmount, stakeAmount);

    expect(await vault.stakedBalance(user1.address)).to.equal(stakeAmount);
    expect(await vault.liquidTokens(user1.address)).to.equal(stakeAmount);
  });

  it("Should handle multiple users staking", async function () {
    const stake1 = ethers.parseEther("1.0");
    const stake2 = ethers.parseEther("2.0");

    await vault.connect(user1).stake({ value: stake1 });
    await vault.connect(user2).stake({ value: stake2 });

    expect(await vault.totalStaked()).to.equal(stake1 + stake2);
    expect(await vault.totalLiquidTokens()).to.equal(stake1 + stake2);
  });
});
```

### Deployment Scripts

Create flexible deployment scripts with proper error handling:

```typescript
// scripts/deploy.ts
import { ethers } from "hardhat";
import { writeFileSync } from "fs";

async function main() {
  const [deployer] = await ethers.getSigners();

  console.log("Deploying contracts with the account:", deployer.address);
  console.log("Account balance:", (await ethers.provider.getBalance(deployer.address)).toString());

  const validatorAddress = process.env.VALIDATOR_ADDRESS || "0x1234567890123456789012345678901234567890";

  const VaultFactory = await ethers.getContractFactory("LiquidStakingVault");
  const vault = await VaultFactory.deploy(validatorAddress);
  await vault.waitForDeployment();

  const deploymentInfo = {
    contractAddress: await vault.getAddress(),
    deployer: deployer.address,
    validatorAddress,
    blockNumber: await ethers.provider.getBlockNumber(),
    timestamp: new Date().toISOString(),
    network: (await ethers.provider.getNetwork()).name
  };

  console.log("LiquidStakingVault deployed to:", deploymentInfo.contractAddress);

  // Save deployment info
  writeFileSync(
    `deployments/${deploymentInfo.network}-deployment.json`,
    JSON.stringify(deploymentInfo, null, 2)
  );
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

## Development Best Practices

### Gas Optimization

Use built-in tools to optimize gas usage:

```bash
# Foundry gas reporting
forge test --gas-report

# Hardhat gas reporting (configured in hardhat.config.js)
npx hardhat test

# Foundry gas profiling for specific function
forge test --match-test testStaking --gas-report
```

### Security Testing

Implement comprehensive security testing:

```solidity
// test/LiquidStakingVault.invariant.t.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../src/CosmosEVMExample.sol";

contract InvariantTest is Test {
    LiquidStakingVault public vault;

    function setUp() public {
        vault = new LiquidStakingVault(address(0x1234));
    }

    // Invariant: Total liquid tokens should never exceed total staked
    function invariant_liquidTokensNeverExceedStaked() public {
        assertLe(vault.totalLiquidTokens(), vault.totalStaked());
    }

    // Invariant: Contract balance should match total staked
    function invariant_balanceMatchesTotalStaked() public {
        assertEq(address(vault).balance, vault.totalStaked());
    }
}
```

### Continuous Integration

Set up CI workflows for automated testing:

```yaml
# .github/workflows/test.yml
name: Test
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Run Forge build
        run: forge build --sizes

      - name: Run Forge tests
        run: forge test -vvv --gas-report

      - name: Run Forge coverage
        run: forge coverage --report lcov
```

## Next Steps

With your development environment configured, move on to comprehensive smart contract development:

<Card title="Smart Contract Development & Deployment" href="/docs/evm/developers/smart-contract-development">
  Deep dive into writing, testing, and deploying contracts with Cosmos EVM specific considerations.
</Card>
