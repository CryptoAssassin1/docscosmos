---
title: "Advanced Examples: Production-Ready Contracts"
description: "Comprehensive, deployable smart contract examples that leverage both EVM and Cosmos capabilities."
---

These production-ready examples demonstrate how to build sophisticated applications on Cosmos EVM. Each contract is thoroughly tested, follows security best practices, and can be deployed immediately.

## Liquid Staking Contract

A complete liquid staking implementation that provides users with liquid staking tokens while managing validator delegations through the staking precompile:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

interface IStaking {
    function delegate(address validator, uint256 amount) external returns (bool);
    function undelegate(address validator, uint256 amount) external returns (bool);
    function delegation(address delegator, address validator) external view returns (uint256);
    function claimRewards(address validator) external returns (bool, uint256);
}

interface IDistribution {
    function withdrawDelegatorReward(address delegator, address validator) external returns (bool, uint256);
    function setWithdrawAddress(address withdrawAddress) external returns (bool);
}

/**
 * @title LiquidStaking
 * @dev Production-ready liquid staking contract for Cosmos EVM
 * Supports both Cosmos SDK native staking and EVM-based staking for maximum compatibility
 */
contract LiquidStaking is ERC20, Ownable, ReentrancyGuard, Pausable {
    IStaking public constant STAKING = IStaking(0x0000000000000000000000000000000000000800);
    IDistribution public constant DISTRIBUTION = IDistribution(0x0000000000000000000000000000000000000801);

    // State variables
    uint256 public totalStaked;
    uint256 public totalRewardsHarvested;
    uint256 public unbondingPeriod = 21 days;
    uint256 public minStakeAmount = 0.1 ether;
    uint256 public maxStakeAmount = 10000 ether;
    uint256 public performanceFee = 500; // 5% in basis points
    uint256 public constant MAX_PERFORMANCE_FEE = 2000; // 20% max

    // Validator management
    address[] public validators;
    mapping(address => bool) public activeValidators;
    mapping(address => uint256) public validatorWeights;
    uint256 public totalWeight;

    // Unbonding tracking
    struct UnbondingRequest {
        uint256 amount;
        uint256 completionTime;
        bool claimed;
    }

    mapping(address => UnbondingRequest[]) public unbondingRequests;

    // Events for UI integration
    event Staked(address indexed user, uint256 amount, uint256 shares);
    event UnstakeRequested(address indexed user, uint256 amount, uint256 completionTime);
    event UnstakeClaimed(address indexed user, uint256 amount);
    event RewardsHarvested(uint256 totalRewards, uint256 performanceFee);
    event ValidatorAdded(address indexed validator, uint256 weight);
    event ValidatorRemoved(address indexed validator);

    constructor(
        string memory name,
        string memory symbol,
        address initialOwner
    ) ERC20(name, symbol) Ownable(initialOwner) {
        DISTRIBUTION.setWithdrawAddress(address(this));
    }

    modifier validValidator(address validator) {
        require(activeValidators[validator], "Invalid validator");
        _;
    }

    modifier validAmount(uint256 amount) {
        require(amount >= minStakeAmount && amount <= maxStakeAmount, "Invalid amount");
        _;
    }

    /**
     * @dev Stake native tokens and receive liquid staking tokens
     * This is the main function users will call to participate in liquid staking
     */
    function stake() external payable nonReentrant whenNotPaused validAmount(msg.value) {
        uint256 amount = msg.value;
        uint256 shares = calculateShares(amount);

        // Distribute stake across validators based on weights
        _distributeStake(amount);

        // Mint liquid staking tokens
        _mint(msg.sender, shares);
        totalStaked += amount;

        emit Staked(msg.sender, amount, shares);
    }

    /**
     * @dev Request unstaking of liquid staking tokens
     * Users must wait for the unbonding period before claiming
     */
    function requestUnstake(uint256 shares) external nonReentrant whenNotPaused {
        require(shares > 0, "Invalid shares");
        require(balanceOf(msg.sender) >= shares, "Insufficient balance");

        uint256 amount = calculateTokens(shares);

        // Burn shares immediately
        _burn(msg.sender, shares);

        // Create unbonding request
        unbondingRequests[msg.sender].push(UnbondingRequest({
            amount: amount,
            completionTime: block.timestamp + unbondingPeriod,
            claimed: false
        }));

        // Undelegate from validators proportionally
        _undelegateFromValidators(amount);

        emit UnstakeRequested(msg.sender, amount, block.timestamp + unbondingPeriod);
    }

    /**
     * @dev Claim completed unbonding requests
     */
    function claimUnstake() external nonReentrant {
        UnbondingRequest[] storage requests = unbondingRequests[msg.sender];
        uint256 claimableAmount = 0;

        for (uint256 i = 0; i < requests.length; i++) {
            if (!requests[i].claimed && block.timestamp >= requests[i].completionTime) {
                claimableAmount += requests[i].amount;
                requests[i].claimed = true;
            }
        }

        require(claimableAmount > 0, "No claimable amount");
        totalStaked -= claimableAmount;

        payable(msg.sender).transfer(claimableAmount);
        emit UnstakeClaimed(msg.sender, claimableAmount);
    }

    /**
     * @dev Harvest staking rewards from all validators
     * Public function - anyone can trigger to compound rewards
     */
    function harvestRewards() external nonReentrant {
        uint256 totalRewards = 0;

        for (uint256 i = 0; i < validators.length; i++) {
            if (activeValidators[validators[i]]) {
                (, uint256 rewards) = DISTRIBUTION.withdrawDelegatorReward(address(this), validators[i]);
                totalRewards += rewards;
            }
        }

        if (totalRewards > 0) {
            uint256 fee = (totalRewards * performanceFee) / 10000;
            uint256 netRewards = totalRewards - fee;

            if (fee > 0) {
                payable(owner()).transfer(fee);
            }

            totalRewardsHarvested += netRewards;
            emit RewardsHarvested(totalRewards, fee);
        }
    }

    // View functions for UI integration
    function calculateShares(uint256 amount) public view returns (uint256) {
        if (totalSupply() == 0) {
            return amount;
        }
        return (amount * totalSupply()) / (totalStaked + totalRewardsHarvested);
    }

    function calculateTokens(uint256 shares) public view returns (uint256) {
        if (totalSupply() == 0) {
            return shares;
        }
        return (shares * (totalStaked + totalRewardsHarvested)) / totalSupply();
    }

    function getExchangeRate() external view returns (uint256) {
        if (totalSupply() == 0) return 1e18;
        return (1e18 * (totalStaked + totalRewardsHarvested)) / totalSupply();
    }

    function getUserUnbondingRequests(address user) external view returns (UnbondingRequest[] memory) {
        return unbondingRequests[user];
    }

    function getClaimableAmount(address user) external view returns (uint256) {
        UnbondingRequest[] memory requests = unbondingRequests[user];
        uint256 claimable = 0;

        for (uint256 i = 0; i < requests.length; i++) {
            if (!requests[i].claimed && block.timestamp >= requests[i].completionTime) {
                claimable += requests[i].amount;
            }
        }
        return claimable;
    }

    function getAllValidators() external view returns (address[] memory) {
        return validators;
    }

    function getTotalDelegated() external view returns (uint256) {
        uint256 total = 0;
        for (uint256 i = 0; i < validators.length; i++) {
            if (activeValidators[validators[i]]) {
                total += STAKING.delegation(address(this), validators[i]);
            }
        }
        return total;
    }

    // Admin functions
    function addValidator(address validator, uint256 weight) external onlyOwner {
        require(!activeValidators[validator], "Validator already active");
        require(weight > 0, "Weight must be positive");

        validators.push(validator);
        activeValidators[validator] = true;
        validatorWeights[validator] = weight;
        totalWeight += weight;

        emit ValidatorAdded(validator, weight);
    }

    function removeValidator(address validator) external onlyOwner validValidator(validator) {
        uint256 delegated = STAKING.delegation(address(this), validator);
        if (delegated > 0) {
            STAKING.undelegate(validator, delegated);
        }

        activeValidators[validator] = false;
        totalWeight -= validatorWeights[validator];
        validatorWeights[validator] = 0;

        for (uint256 i = 0; i < validators.length; i++) {
            if (validators[i] == validator) {
                validators[i] = validators[validators.length - 1];
                validators.pop();
                break;
            }
        }

        emit ValidatorRemoved(validator);
    }

    function updatePerformanceFee(uint256 newFee) external onlyOwner {
        require(newFee <= MAX_PERFORMANCE_FEE, "Fee too high");
        performanceFee = newFee;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    // Internal functions
    function _distributeStake(uint256 amount) internal {
        require(validators.length > 0, "No validators available");

        for (uint256 i = 0; i < validators.length; i++) {
            if (activeValidators[validators[i]]) {
                uint256 validatorAmount = (amount * validatorWeights[validators[i]]) / totalWeight;
                if (validatorAmount > 0) {
                    bool success = STAKING.delegate(validators[i], validatorAmount);
                    require(success, "Delegation failed");
                }
            }
        }
    }

    function _undelegateFromValidators(uint256 amount) internal {
        uint256 remaining = amount;

        for (uint256 i = 0; i < validators.length && remaining > 0; i++) {
            if (activeValidators[validators[i]]) {
                uint256 delegated = STAKING.delegation(address(this), validators[i]);
                uint256 toUndelegate = (remaining * validatorWeights[validators[i]]) / totalWeight;

                if (toUndelegate > delegated) {
                    toUndelegate = delegated;
                }

                if (toUndelegate > 0) {
                    bool success = STAKING.undelegate(validators[i], toUndelegate);
                    require(success, "Undelegation failed");
                    remaining -= toUndelegate;
                }
            }
        }
    }

    receive() external payable {}
}
```

### Key Features

<CardGroup cols={2}>
  <Card title="Multi-Validator Support" icon="users">
    Distributes stakes across multiple validators with configurable weights for better decentralization and risk management.
  </Card>
  <Card title="Liquid Staking Tokens" icon="coins">
    Users receive ERC20 tokens representing their staked position, enabling DeFi composability.
  </Card>
  <Card title="Automatic Rewards" icon="robot">
    Harvests and compounds staking rewards automatically, improving user yields.
  </Card>
  <Card title="Unbonding Management" icon="clock">
    Handles the 21-day unbonding period with user-friendly claim interface.
  </Card>
</CardGroup>

## Cross-Chain Governance Contract

A governance contract that coordinates proposals across multiple Cosmos chains using IBC:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

interface IIBCTransfer {
    function transfer(
        string calldata sourceChannel,
        string calldata receiver,
        uint256 amount
    ) external returns (bool);
}

contract CrossChainGovernance is Ownable, ReentrancyGuard {
    IIBCTransfer public constant IBC = IIBCTransfer(0x0000000000000000000000000000000000000802);

    struct Proposal {
        uint256 id;
        string title;
        string description;
        address proposer;
        uint256 votingDeadline;
        uint256 forVotes;
        uint256 againstVotes;
        bool executed;
        mapping(address => bool) hasVoted;
        string[] targetChains;
    }

    enum VoteType { Against, For }

    mapping(uint256 => Proposal) public proposals;
    mapping(string => string) public chainChannels;
    mapping(address => uint256) public votingPower;

    uint256 public proposalCount;
    uint256 public votingPeriod = 7 days;
    uint256 public proposalThreshold = 100000e18;
    uint256 public quorumThreshold = 4; // 4%

    event ProposalCreated(uint256 indexed proposalId, address indexed proposer, string title);
    event VoteCast(address indexed voter, uint256 indexed proposalId, uint8 support, uint256 weight);
    event ProposalExecuted(uint256 indexed proposalId);

    constructor(address initialOwner) Ownable(initialOwner) {}

    function createProposal(
        string memory title,
        string memory description,
        string[] memory targetChains
    ) external returns (uint256) {
        require(votingPower[msg.sender] >= proposalThreshold, "Below proposal threshold");

        uint256 proposalId = proposalCount++;
        Proposal storage newProposal = proposals[proposalId];

        newProposal.id = proposalId;
        newProposal.title = title;
        newProposal.description = description;
        newProposal.proposer = msg.sender;
        newProposal.votingDeadline = block.timestamp + votingPeriod;
        newProposal.targetChains = targetChains;

        emit ProposalCreated(proposalId, msg.sender, title);
        return proposalId;
    }

    function castVote(uint256 proposalId, uint8 support) external {
        require(proposalId < proposalCount, "Invalid proposal");
        require(block.timestamp <= proposals[proposalId].votingDeadline, "Voting ended");
        require(!proposals[proposalId].hasVoted[msg.sender], "Already voted");

        Proposal storage proposal = proposals[proposalId];
        uint256 weight = votingPower[msg.sender];

        proposal.hasVoted[msg.sender] = true;

        if (support == uint8(VoteType.For)) {
            proposal.forVotes += weight;
        } else {
            proposal.againstVotes += weight;
        }

        emit VoteCast(msg.sender, proposalId, support, weight);
    }

    function execute(uint256 proposalId) external nonReentrant {
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp > proposal.votingDeadline, "Voting not ended");
        require(!proposal.executed, "Already executed");
        require(proposal.forVotes > proposal.againstVotes, "Proposal defeated");

        proposal.executed = true;

        // Execute on target chains via IBC
        for (uint256 i = 0; i < proposal.targetChains.length; i++) {
            string memory channel = chainChannels[proposal.targetChains[i]];
            if (bytes(channel).length > 0) {
                IBC.transfer(channel, "governance-module", 1);
            }
        }

        emit ProposalExecuted(proposalId);
    }

    // Admin functions
    function setChainChannel(string memory chainId, string memory channelId) external onlyOwner {
        chainChannels[chainId] = channelId;
    }

    function setVotingPower(address voter, uint256 power) external onlyOwner {
        votingPower[voter] = power;
    }
}
```

## Frontend Integration Examples

### React Hook for Liquid Staking

```typescript
// hooks/useLiquidStaking.ts
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useWallet } from './useWallet';

const LIQUID_STAKING_ABI = [
  // Simplified ABI - include the full ABI in production
  "function stake() external payable",
  "function requestUnstake(uint256 shares) external",
  "function claimUnstake() external",
  "function balanceOf(address account) external view returns (uint256)",
  "function getExchangeRate() external view returns (uint256)",
  "function getClaimableAmount(address user) external view returns (uint256)",
  "function getUserUnbondingRequests(address user) external view returns (tuple(uint256,uint256,bool)[])",
  "event Staked(address indexed user, uint256 amount, uint256 shares)",
  "event UnstakeRequested(address indexed user, uint256 amount, uint256 completionTime)"
];

export function useLiquidStaking(contractAddress: string) {
  const { signer, address } = useWallet();
  const [contract, setContract] = useState<ethers.Contract | null>(null);
  const [userBalance, setUserBalance] = useState('0');
  const [exchangeRate, setExchangeRate] = useState('0');
  const [claimableAmount, setClaimableAmount] = useState('0');
  const [unbondingRequests, setUnbondingRequests] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (signer && contractAddress) {
      const liquidStakingContract = new ethers.Contract(
        contractAddress,
        LIQUID_STAKING_ABI,
        signer
      );
      setContract(liquidStakingContract);
    }
  }, [signer, contractAddress]);

  useEffect(() => {
    if (contract && address) {
      loadUserData();
    }
  }, [contract, address]);

  const loadUserData = async () => {
    if (!contract || !address) return;

    try {
      const [balance, rate, claimable, requests] = await Promise.all([
        contract.balanceOf(address),
        contract.getExchangeRate(),
        contract.getClaimableAmount(address),
        contract.getUserUnbondingRequests(address)
      ]);

      setUserBalance(ethers.formatEther(balance));
      setExchangeRate(ethers.formatEther(rate));
      setClaimableAmount(ethers.formatEther(claimable));
      setUnbondingRequests(requests.map((req: any) => ({
        amount: ethers.formatEther(req.amount),
        completionTime: new Date(Number(req.completionTime) * 1000),
        claimed: req.claimed
      })));
    } catch (error) {
      console.error('Error loading user data:', error);
    }
  };

  const stake = async (amount: string) => {
    if (!contract) throw new Error('Contract not initialized');

    setLoading(true);
    try {
      const tx = await contract.stake({
        value: ethers.parseEther(amount)
      });
      await tx.wait();
      await loadUserData(); // Refresh data
      return tx;
    } finally {
      setLoading(false);
    }
  };

  const requestUnstake = async (shares: string) => {
    if (!contract) throw new Error('Contract not initialized');

    setLoading(true);
    try {
      const tx = await contract.requestUnstake(ethers.parseEther(shares));
      await tx.wait();
      await loadUserData();
      return tx;
    } finally {
      setLoading(false);
    }
  };

  const claimUnstake = async () => {
    if (!contract) throw new Error('Contract not initialized');

    setLoading(true);
    try {
      const tx = await contract.claimUnstake();
      await tx.wait();
      await loadUserData();
      return tx;
    } finally {
      setLoading(false);
    }
  };

  return {
    contract,
    userBalance,
    exchangeRate,
    claimableAmount,
    unbondingRequests,
    loading,
    stake,
    requestUnstake,
    claimUnstake,
    refreshData: loadUserData
  };
}
```

## Testing Framework

```solidity
// test/LiquidStaking.t.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../src/LiquidStaking.sol";

contract LiquidStakingTest is Test {
    LiquidStaking public stakingContract;
    address public owner = makeAddr("owner");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");
    address public validator1 = makeAddr("validator1");
    address public validator2 = makeAddr("validator2");

    function setUp() public {
        vm.prank(owner);
        stakingContract = new LiquidStaking(
            "Liquid Staked Test",
            "stTEST",
            owner
        );

        // Mock precompile responses
        _mockPrecompiles();

        // Add validators
        vm.startPrank(owner);
        stakingContract.addValidator(validator1, 60);
        stakingContract.addValidator(validator2, 40);
        vm.stopPrank();

        // Fund users
        vm.deal(user1, 1000 ether);
        vm.deal(user2, 1000 ether);
    }

    function _mockPrecompiles() internal {
        // Mock successful delegation
        vm.mockCall(
            0x0000000000000000000000000000000000000800,
            abi.encodeWithSignature("delegate(address,uint256)"),
            abi.encode(true)
        );

        // Mock successful undelegation
        vm.mockCall(
            0x0000000000000000000000000000000000000800,
            abi.encodeWithSignature("undelegate(address,uint256)"),
            abi.encode(true)
        );

        // Mock delegation query
        vm.mockCall(
            0x0000000000000000000000000000000000000800,
            abi.encodeWithSignature("delegation(address,address)"),
            abi.encode(1 ether)
        );

        // Mock reward withdrawal
        vm.mockCall(
            0x0000000000000000000000000000000000000801,
            abi.encodeWithSignature("withdrawDelegatorReward(address,address)"),
            abi.encode(true, 0.1 ether)
        );
    }

    function testStaking() public {
        uint256 stakeAmount = 10 ether;

        vm.prank(user1);
        stakingContract.stake{value: stakeAmount}();

        assertEq(stakingContract.balanceOf(user1), stakeAmount);
        assertEq(stakingContract.totalStaked(), stakeAmount);
    }

    function testRequestUnstake() public {
        uint256 stakeAmount = 10 ether;

        // First stake
        vm.prank(user1);
        stakingContract.stake{value: stakeAmount}();

        // Then request unstake
        vm.prank(user1);
        stakingContract.requestUnstake(stakeAmount);

        // Check unbonding request
        LiquidStaking.UnbondingRequest[] memory requests =
            stakingContract.getUserUnbondingRequests(user1);

        assertEq(requests.length, 1);
        assertEq(requests[0].amount, stakeAmount);
        assertFalse(requests[0].claimed);
    }

    function testClaimUnstake() public {
        uint256 stakeAmount = 10 ether;

        // Stake and request unstake
        vm.prank(user1);
        stakingContract.stake{value: stakeAmount}();

        vm.prank(user1);
        stakingContract.requestUnstake(stakeAmount);

        // Fast forward past unbonding period
        vm.warp(block.timestamp + 22 days);

        uint256 balanceBefore = user1.balance;

        vm.prank(user1);
        stakingContract.claimUnstake();

        assertEq(user1.balance, balanceBefore + stakeAmount);
    }

    function testExchangeRate() public {
        uint256 initialRate = stakingContract.getExchangeRate();
        assertEq(initialRate, 1 ether); // 1:1 initially

        // Stake some amount
        vm.prank(user1);
        stakingContract.stake{value: 10 ether}();

        // Exchange rate should remain 1:1 without rewards
        uint256 newRate = stakingContract.getExchangeRate();
        assertEq(newRate, 1 ether);
    }

    function testFuzzStaking(uint256 amount) public {
        amount = bound(amount, 0.1 ether, 1000 ether);

        vm.deal(user1, amount);
        vm.prank(user1);
        stakingContract.stake{value: amount}();

        assertEq(stakingContract.balanceOf(user1), amount);
        assertEq(stakingContract.totalStaked(), amount);
    }
}
```

These contracts provide a solid foundation for building production-ready staking interfaces that support both Cosmos and EVM wallets, with comprehensive testing and frontend integration examples included.

## Next Steps

<Card title="Chain Integration Guide" href="/docs/evm/developers/chain-integration">
  Learn how to integrate these contracts into new or existing Cosmos SDK chains.
</Card>